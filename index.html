<!DOCTYPE html>
<html>
  <head>
    <title>Hello World!</title>
  </head>
  <body>
    <h1>Bowwow</h1>
    <div id="app">
      <h2>voice</h2>
      <div>
        <div v-with="points: freqPoints" v-component="graph"></div>
        <div v-with="points: timesPoints" v-component="graph"></div>
      </div>
      <h2>video</h2>
      <div>
        <div v-with="points: videoDiffPoints" v-component="graph"></div>
        
        <button v-on="click: capture">capture</button>
        <img v-attr="src: videoDiff">
        <video v-el="video"></video>
        <canvas v-el="videoCanvas"></canvas>
      </div>
    </div>
    <template id="graph">
      <svg v-attr="width: width, height : height, viewBox: viewBox">
        <path stroke="black" width=1 fill="transparent" v-attr="d:paths"></path>
      </svg>
    </template>
  </body>
  <script>
  function uintToAverage(array){
    var sum = 0
    var length = array.length 
    for(var i = 0; i < length; i++){
      sum += array[i]
    }
    return sum / length
  }
  
  var Vue = require("vue")
  var resemble = require("resemblejs").resemble
  
  Vue.component("graph", {
    template : "#graph",  
    data : function(){
      return {
        width : 100,
        height : 100,
      }
    },
    computed: {
      viewBox : function(){
        return [0, -this.$data.height, this.$data.width, this.$data.height].join(" ")
      },
      paths : function(){
        var self = this
        var pts = this.points
        
        if(pts.length === 0){
          return ""
        }
        
        var paths = pts.map(function(m, i){
          if(typeof m === "number"){
            m = [i / self.$data.width, m]
          }
          var x = self.$data.width * m[0]
          var y = -self.$data.height * m[1]
          return x + "," + y
        }).join(" ")
        return "M" + paths
      }
    }
  })
  var vm = new Vue({
    data : {
      times: [],
      freq: [],
      videoDiffPoints : [],
      videoDiff: null
    },
    methods: {
      normalizeValue : function(x, y, maxX, maxY){
        var normX = x / maxX
        var normY = y / maxY
        return [normX, normY]
      },
      toPoints : function(byteArray){
        var pts = []
        var length =  byteArray.length
        var sampling = 10        
        for(var i=0; i < length; i+=sampling){
          var pt = this.normalizeValue(i, byteArray[i], length ,255)
          pts.push(pt)
        }
        return pts 
      },
      onUserMediaSuccess: function(stream){
        var self = this
        this.handleAudioProgress(stream, function(freq, times){
          self.$data.freq = freq
          self.$data.times = times
        })
        var video = this.$$.video
        video.src = window.URL.createObjectURL(stream)
        video.volume = 0
        video.play()
      },
      handleAudioProgress: function(stream, onAudioProgress){
        this._handleAudioProgress(this.$data.audioContext, this.$data.javascriptNode, stream, onAudioProgress)
      },
      _handleAudioProgress: function(audioContext, javascriptNode, stream, onAudioProgress){
        var microphone = audioContext.createMediaStreamSource(stream);  
        var analyser = audioContext.createAnalyser();
        analyser.smoothingTimeConstant = 0.3;
        analyser.fftSize = 1024;
        microphone.connect(analyser);
        
        analyser.connect(javascriptNode);
        javascriptNode.connect(audioContext.destination);
        javascriptNode.onaudioprocess = function() {
          var freq =  new Uint8Array(analyser.frequencyBinCount)
          var times = new Uint8Array(analyser.fftSize)
          analyser.getByteFrequencyData(freq)
          analyser.getByteTimeDomainData(times)
          onAudioProgress(freq, times)
        }
      },
      captureCurrentVideo : function(){
        var type = "image/png"
        var dataUrl = this.$$.videoCanvas.toDataURL(type)
        return dataUrl
      },
      renderVideoCanvas : function(){
        var video = this.$$.video
        var videoAspect = video.clientHeight / video.clientWidth 
        var ctxWidth = 320
        var ctxHeight = ctxWidth / videoAspect
        
        var ctx = this.$$.videoCanvas.getContext("2d")
        ctx.drawImage(video, 0, 0, ctxWidth , ctxHeight)// ,0, 0 ,ctxWidth , ctxHeight)
      },
      capture : function(){
        var oldData = this.captureCurrentVideo()
        this.renderVideoCanvas()
        var newData = this.captureCurrentVideo()
        var diff = resemble(oldData).compareTo(newData)
        var self = this
        diff.ignoreColors().onComplete(function(data){
          //console.log(data.getImageDataUrl())
          self.$data.videoDiff = data.getImageDataUrl()
          self.$data.videoDiffPoints.unshift(Number(data.misMatchPercentage)/100)
        })
        
        
      }
    },
    computed : {
      freqPoints : function(){
        return this.toPoints(this.freq)
      },
      timesPoints : function(){
        return this.toPoints(this.times)
      }
    },
    created : function(){
      var self = this

      this.$data.audioContext = new webkitAudioContext();
      this.$data.javascriptNode = this.$data.audioContext.createScriptProcessor(2048, 1, 1);
      
      navigator.webkitGetUserMedia({ video: true, audio: true}, this.onUserMediaSuccess, error)
      
    }
    
  })
  vm.$mount("#app")
  // TODO:調整可能にする
  setInterval(function(){
    vm.capture()
  }, 1000)
  function error(err){
    //console.log("An error occured! " + err);
  }
  </script>
</html>